#+TITLE: A Short Introduction To Parsing

#+begin_quote
Any pidgin algebra can be dressed up as pidgin English to please the generals. [[https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf][Landin 1966, The Next 700 Programming Languages]]
#+end_quote

In this exercise we learn parsing from first principles.

The learning method is by induction, which means we toss you in the water at successively greater depths; before you know it, you'll have learned to swim!

Your swimming coach is Socrates.

Socrates asks you to pretend that your inner 10-year-old is locked in a room. Through the window you feed a strip of paper, one character at a time. At each step, Socrates asks your 10-year-old:
- What do you make of this new character?
- What are you expecting next?
- If the paper stops here, what answer would you give?

* A Simple Calculator

in your favourite language, write a program or a function that, given the input string, takes it apart, computes it in a way that would satisfy your math teacher in school. But using ~eval()~ is cheating!

In Python, the simplest possible parser checks if the input is a single digit:
#+begin_src python :tangle parsers.py
  #!/usr/bin/python3
  import re
  def prsr1 (str):
      if len(str) == 1:
         if ord('0') <= ord(str) <= ord('9'):
             return(int(str))
         else:
             print("i can only handle a simple integer right now")
             raise ValueError
      else:
          print("i can only handle a single character right now")
          raise ValueError
  print("2 should be 2:", prsr1("2") == 2)
#+end_src

Same idea in Javascript, but with a tokenization step. Well, this is Typescript, so we need a ~tsc~ step, but aside from that:

#+begin_src typescript :tangle parsers.ts
  export function prsr1 (str) {
    const tokens = str.split(/\b/);
    console.log(tokens);
    if (tokens.length == 1
      && "0".charCodeAt(0) <= tokens[0].charCodeAt(0)
      && "9".charCodeAt(0) >= tokens[0].charCodeAt(0)
       ) { return parseInt(tokens[0]) }
    else {
      console.error("expecting a single numeric digit")
    }
  }
#+end_src

Work down the table row by row, evolving your program to be able to handle both the current row and all earlier rows.

#+begin_src typescript :tangle parsers.ts
  export function prsr2 (str) {
    const tokens = str.split(/\b/);
    console.log(tokens);
    if (tokens.length == 1) { return parseInt(tokens[0]) }
    if ((tokens[0]+tokens[2]).match(/^[0-9]+$/)) {
      if (tokens[1] == "*") { return tokens[0] * tokens[2]; }
      if (tokens[1] == "+") { return parseInt(tokens[0]) + parseInt(tokens[2]) }
    }
  }
  console.log(prsr2("2") + ` should be 2`)
  console.log(prsr2("2+2") + ` should be 4`)
  console.log(prsr2("2*4") + ` should be 8`)
#+end_src

#+begin_src python :tangle parsers.py
  def prsr2 (str):
      tokens = re.split(r'\b',str)
      if len(tokens) == 3:
          return(tokens[1])
      if len(tokens) == 5:
          if (tokens[2] == "*"): return int(tokens[1]) * int(tokens[3])
          if (tokens[2] == "+"): return int(tokens[1]) + int(tokens[3])
  print(prsr2("2+2"), "should be 4")
#+end_src

Along the way you will throw up your hands and say "the approach I've been using so far won't work for the next problem!" That is fine. It is called "progress".

Remember, your inner 10-year-old already knows everything you need to do this!

You should be able to dialogue with your inner 10-year-old. Go character by character. What does your 10-year-old, locked in the room, have to say, for each new character on the strip of paper?

| input string                | learning objective                               |
|-----------------------------+--------------------------------------------------|
| 4                           | convert a string to an integer and print it      |
| 6                           | handle different numbers                         |
| 8                           | handle different numbers                         |
| 2+2                         | "+" is a binary operator                         |
| 2 + 2                       | discard whitespace                               |
| 2 + \nbsp{}\nbsp{}\nbsp{} 2 | discard arbitrary whitespace                     |
| 2 + 4 + 6                   | handle different numbers and multiple operators  |
| 2 + 4 + 6 + 8               | handle different numbers and multiple operators  |
| 2 + 4 + 6 - 8               | handle a mix of operators                        |
| 2 + 10                      | numbers can have multiple digits! "tokenization" |
| 10 + 22                     | multiple digits on both sides                    |
| 10 * 10                     | introduce the multiplication operator            |
| 10 ** 2                     | tokenization is for operators too                |
| 22 / 10                     | introduce division                               |
| 22 *                        | what happens when you run out of input?          |
| 22 / (10)                   | introduce parentheses                            |
| 22 / (5+5)                  | introduce parentheses for real                   |
| -22                         | introduce negative numbers                       |
| -22 / (5+5)                 | introduce negative numbers in action             |
| (50+50) / -22               | introduce negative numbers in inconvenient spots |
| -22 / (-5+12)               | introduce negative numbers in other spots        |
| (0-22) / (2+2)              | do your parens really work?                      |
| (11+11) / 2 + 2 * 2         | operator precedence                              |
| (0-(11                      | give the most detailed error message possible.   |
| 11 + +10                    | give the most detailed error message possible.   |
| 11 + -10                    | this is not an error.                            |
| 2+4*6                       | operator precedence                              |
| 2*4+6                       | operator precedence                              |
| 2*(4+6)                     | do your parens still work?                       |

** Error messages

When you run out of input or deal with an ill-formed input string, give the most appropriate error message you can. What does your favourite programming language do when asked to deal with the same input?

** Example Runs

From emacs org-mode, editing this README.org, C-c C-v C-t to tangle output.

*** Python

#+begin_example
$ python3
Python 3.8.5 (default, Jul 21 2020, 10:48:26)
[Clang 11.0.3 (clang-1103.0.32.62)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import parsers
2 should be 2: True
4 should be 4
>>> parsers.prsr1("6")
6
>>> parsers.prsr1("t")
i can only handle a simple integer right now
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/mengwong/src/smucclaw/complaw/doc/ex-mathlang-20200821/parsers.py", line 9, in prsr1
    raise ValueError
ValueError
>>> parsers.prsr1("two")
i can only handle a single character right now
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/mengwong/src/smucclaw/complaw/doc/ex-mathlang-20200821/parsers.py", line 12, in prsr1
    raise ValueError
ValueError
#+end_example

*** Javascript / Typescript

You may need to npm i -g typescript

#+begin_example
$ tsc parsers.ts
$ node
Welcome to Node.js v14.4.0.
Type ".help" for more information.
> p=require('./parsers.js')
[ '2' ]
2 should be 2
[ '2', '+', '2' ]
4 should be 4
[ '2', '*', '4' ]
8 should be 8
{
  __esModule: true,
  prsr1: [Function: prsr1],
  prsr2: [Function: prsr2]
}
> p.prsr1("two")
[ 'two' ]
expecting a single numeric digit
undefined
> p.prsr1("0")
[ '0' ]
0

#+end_example

** Learning Objectives
Technical terms for the tricks you performed along the way:
- tokenization
- lexing
- construction of an abstract syntax tree
- recursive evaluation
- definition of operator precedence
- prefix vs infix notation
- binary vs unary operators

Read: http://otfried.org/courses/cs206/notes/calculator.pdf

* Part 2: Use GF to turn arbitrary math expressions into English

Take a look at https://cdecl.org/

That's a bidirectional English-to-C converter.

Now imagine a bidirectional English-to-Math converter. You've played this game before, as a 12 year old: they're called word problems in math class.

Write a GF grammar that, given the abstract syntax tree you parsed, produces a coherent English equivalent. As in, "The sum of two and two is four." "Twenty-two divided by the sum of five and five is 2.2".

* Now that you've done it by hand

Imagine other languages and their grammars; wouldn't it be nice to abstract out to a separate layer the idea of a lexer? Given a language definition of some sort, it should be possible to automate the code-generation of a lexer and compiler. That's why "yacc" is called "yet another compiler compiler". And that's exactly what Eric Schmidt did before his days as a Google billionaire CEO -- he wrote "lex" as an intern at Bell Labs in 1975.

If you come from Javascript, look at [[https://pegjs.org/online][PEG.js]].

In other languages, see: http://www.rosettacode.org/wiki/Arithmetic_evaluation


