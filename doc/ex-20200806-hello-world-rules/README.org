#+TITLE: Hello World for Deliverable Rules

Government regulations decree that potatoes may be traded only if they are harvested from plants planted on the two days immediately preceding and following a full moon, unless an exemption is granted by the Director of Agriculture.

* Background

Rules As Code is a fine idea, but very abstract. What could it look like, concretely?

Suppose a client wants to place an order for a Rules As Code project. The client is a system integrator project manager type entity. Their initial architecture diagram breaks down the moving parts thus:

| role          | responsibility                                            |
|---------------+-----------------------------------------------------------|
| App Developer | Produce working front-end UI                              |
|               | which interacts with end-user                             |
|               | based on back-end rules                                   |
|               | to elicit user input                                      |
|               | and produce advisory opinions                             |
|               | and produce documents for filing.                         |
|---------------+-----------------------------------------------------------|
| Back-end      | Produce an API implementing an expert system rule engine: |
| rule engine   | given a current goal and knowledge state,                 |
| developer     | returns a list of working assumptions,                    |
|               | tentative conclusions, and questions to ask,              |
|               | which will help the system get closer to the goal.        |
|               | This rule engine in turn relies on a rule base.           |
|---------------+-----------------------------------------------------------|
| Back-end      | Produce a library of rules consumable by a rule engine:   |
| rule base     | The rules include an ontology / type system,              |
| developer     | forward-chaining (if/then) rules, and                     |
|               | backward-chaining (then/if) rules.                        |
|               | The rules also encode constitutive rules and              |
|               | prescriptive rules.                                       |

In this project, the rule engine and rule base developer are the same party. It is possible that in future, a previously developed rule base can be repurposed and reused. Other apps and rule engines may wish to consume the same rules. Or the front-end app developer may prefer to include the rule base in their single-page app directly, with a minimal embedded rule engine.

* Case, version 1:

Government regulations decree that potatoes may be traded only if they are harvested from plants planted on the two days immediately preceding and following a full moon, unless an exemption is granted by the Director of Agriculture.

Farmers want to know:
- when are the next available dates for planting potatoes?
- what counts as a potato?
- given a past potato already planted on a given date, was that potato legal?
- what is the penalty for planting an illegal potato?
- what paperwork do I need to file, if any, in compliance with this regulation?

Rule developers want to know:
- For the purposes of the regulations, when does a full moon occur?
- What algorithm determines the mapping from a full moon to the two approved days?
- What if a full moon technically occurs at noontime on a given day? In other words the moon is equally full on two nights.

App developers want to know:
- knowing that the rules are strange and arbitrary and may change in the future at any time, what reasonably robust architecture can be expected to survive future regulatory changes without much re-work, if any?

* Assumptions

Let's assume that an authoritative list of full-moon dates exists at https://www.almanac.com/astronomy/moon/full

* Test Cases

** When are the next available dates for planting potatoes?

*** App: data panel in app shows the next four dates available for planting

The app requests dates from a rule engine over the usual JSON API.

#+begin_src json
// the app asks:
{ "request": { "key":  "nextAvailableDates"
             , "for":  "potatoes"
             , "date": "2020-08-06"
             , "asOf": "2020-08-06"
             , "limit": "4"
             , "id":   "1001", "version": "1", "locale": "en_SG" } }

// the rule engine answers:
{ "response": { "id": "1001"
              , "dates": ["2020-09-01", "2020-09-02", "2020-10-01", "2020-10-02"] } }
#+end_src

It's up to the app to convert the dates to a more human-friendly representation.

*** Rule engine: requests relevant rules in an executable form from the rule base

To compute those dates, the rule engine requested the underlying rules from the rule base, in an executable form.

#+begin_src json
  { "request": { "key":  "nextAvailableDates"
               , "for":  "potatoes"
               , "date": "2020-08-06"
               , "asOf": "2020-08-06"
               , "lang": "typescript"
               , "id":   "1002", "version": "1", "locale": "en_SG" } }
#+end_src

The response from the rule base shows up as a non-Turing-complete, "safe" subset of Typescript:

#+begin_src typescript :tangle potato.ts
    function nextAvailableDates (date: Date, asOf: Date, limit: number) : Date[] {
      return legalDates(asOf)
        .filter(x => x >= date)
        .splice(0, limit)
    }

    function legalDates(asOf: Date) : Date[] {
      return fullMoonDates(asOf)
        .flatMap(x => [x, addDays(x,1)])
    }

    function fullMoonDates(asOf: Date) : Date[] {
      return getDatesFromURL("https://www.almanac.com/astronomy/moon/full/")
    }

#+end_src

How did the rule base produce those functions?

*** Rule base

The rule base encodes the original decree in a semantically lossless, machine-readable form:

#+begin_src text :tangle potato.l4
   RULE   1
   PARTY  P
   SHANT  trade Item
   WHEN   Item.isPotato
   UNLESS Item.isLegalPotato
       OR P.hasExemption(FROM DirectorOfAgriculture) // implicitly "THAT P MAY trade Item"
 
   RULE 2
   DEEM Item.isPotato
   WHEN Item.species ~ ["Solanum tuberosum"]
 
   RULE 3
   DEEM Item.isLegalPotato
   WHEN Item.wasPlanted matches anyOf LegalDates
 
   RULE   4
   DEFINE LegalDates
    BEING a list of dates each called LegalDate
    GIVEN FullMoonDates being a list of dates each called FullMoonDate
     EACH LegalDate
  MATCHES FullMoonDate
       OR FullMoonDate + 1
 
   RULE   5
   DEFINE FullMoonDates
 EXTERNAL url "https://www.almanac.com/astronomy/moon/full/"
#+end_src

This is enough information for a parser/interpreter to extract the following functions:

**** in Prolog

The Prolog-executable version of the rule shuffles things around a little to respect execution order:

#+begin_src prolog :noweb-ref prolog
rule(1, P, may, trade(Item)) :- rule(_,isPotato(Item)), rule(_, isLegalPotato(Item)).
rule(1, P, may, trade(Item)) :- hasExemption(P, from(directorOfAgriculture), that(P,may,trade(Item))).
rule(1, P, shant, trade(Item)) :- \+ rule(1, P, may, trade(Item)).
#+end_src

The extraction mechanism sinks the default "SHANT" to the bottom, and promotes the UNLESS exception to the top.

Rules 2 is a straightforward test of set membership.

#+begin_src prolog :noweb-ref prolog
rule(2, isPotato(Item)) :- member(Item.get(species), ["Solanum tuberosum"]).
#+end_src

Rule 3 is a similar test but implemented in a more natively-Prolog style. It needs rule 4.

#+begin_src prolog :noweb-ref prolog
rule(3, isLegalPotato(Item)) :- rule(_,legalDates(Item.get(wasPlanted))).
#+end_src

Rule 4 maps the externally given full-moon-dates to legal dates.

#+begin_src prolog :noweb-ref prolog
rule(4,
     legalDates(Date)) :- rule(_, fullMoonDates(FMD)),
                          ( Date = FMD ; 
                            form_time(FMD,datetime(J0,_)), J1 #= J0+1, form_time(Date,datetime(J1,0)) ).
#+end_src

Rule 5 retrieves the list of full-moon-dates from an external URL, [[https://www.swi-prolog.org/pldoc/man?section=http-clients][the details of which]] we will not go into here; we simulate that retrieval by directly inserting some dates into the store.

#+begin_src prolog :noweb-ref prolog
rule(5, fullMoonDates(2020-1-10)).
rule(5, fullMoonDates(2020-2-8)).
rule(5, fullMoonDates(2020-3-9)).
rule(5, fullMoonDates(2020-4-7)).
rule(5, fullMoonDates(2020-5-6)).
rule(5, fullMoonDates(2020-6-5)).
rule(5, fullMoonDates(2020-7-4)).
rule(5, fullMoonDates(2020-8-2)).
rule(5, fullMoonDates(2020-9-1)).
rule(5, fullMoonDates(2020-10-1)).
rule(5, fullMoonDates(2020-10-30)).
rule(5, fullMoonDates(2020-11-29)).
rule(5, fullMoonDates(2020-12-29)).
#+end_src

Now we can test the rule:

#+begin_src prolog :noweb-ref prolog
potato1(item{species:"Solanum tuberosum", wasPlanted:2020-1-10}).
potato2(item{species:"Solanum tuberosum", wasPlanted:2020-1-11}).
potato3(item{species:"Solanum tuberosum", wasPlanted:2020-1-12}).
hasExemption(nobody, from(no-one), that(nothing)).
#+end_src

And the output is as expected:

#+begin_example

?- potato1(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-10},
Deontic = may .

?- potato2(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-11},
Deontic = may .

?- potato3(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-12},
Deontic = shant.

#+end_example

**** in Haskell

**** in Typescript

we'll pretend we got back fullMoonDates from some URL.
#+begin_src typescript :tangle potato.ts
  function getDatesFromURL(_:string) : Date[] {
  return ([ "2020-01-10",
            "2020-02-08",
            "2020-03-09",
            "2020-04-07",
            "2020-05-06",
            "2020-06-05",
            "2020-07-04",
            "2020-08-02",
            "2020-09-01",
            "2020-10-01",
            "2020-10-30",
            "2020-11-29",
            "2020-12-29" ].map(x=>Date.parse(x)))
  }
#+end_src


**** The encoding/interpretive process involved the following human reasoning:

We know that the correct answer is (intensionally) "the two days before and after a full moon".

The system converts that to the desired (extensional) answer by means of three operations:
1. table lookup against externally provided list of full moon dates
2. a "world knowledge" rule that /somehow knows/ that the two days adjacent to a given night, are the day preceding that night, and the day following.
3. THere is an assumption that a full moon happens at night. But a night spans two dates! Also, a full moon could happen technically during the day -- that's what our data source gives us. So we use another "world knowledge" rule that /cleverly knows/ that if a full moon happens between midnight and noon, the "other allowed day" is the day before; but if a full moon happens between noon and midnight, the "other allowed day" is the day after.

#+begin_src haskell :noweb-ref basicimplementation
legalDates night = [ sameDay night, nextDay night ]
  where sameDay x = x
        nextDay x = addDays 1 x
#+end_src

The rule base encodes the original decree.

#+begin_src typescript
function night2day(nightDate : Date) : Date {
  
}
#+end_src

SQL table of contains authoritative table of moon_dates.

#+begin_src sql
  SELECT * FROM fullMoonDates
   WHERE full_moon_date >= (current_date - 1)
   LIMIT 2
#+end_src

** What counts as a potato?
** Given a past potato already planted on a given date, was that potato legal?
** What is the penalty for planting an illegal potato?
** What paperwork do I need to file, if any, in compliance with this regulation?

* Components by Layer

** Rule Base

** Rule Engine

* Alternative Modes

* Learning Objective

* Case, version 2:

Government drafting offices want to accelerate service delivery.
- They are currently drafting the next edition of the regulations; they want to be able to express the potato rules in code, and then have software extract those rules to English in an automated fashion.
- In version 2 of the rules, potatoes may be legally planted on days immediately preceding and following a full moon, unless one or both of those days is a public holiday, in which case the potato legality window slides to the days before and after the holiday, at the farmer's discretion; but the number of available-planting days may not exceed 2.

Economists want to know: 
- what is a farmer?
- Will Version 2 of the rules favour small producers or large producers? Assuming public holidays are frequent, and assuming the ideal planting period (which has very little to do with the phase of the moon) is relatively short, and the ideal planting period varies by geography, then farmers will want to have discretion over whether to plant before or after the public holiday. In a Big Ag scenario, there is only one farmer, with thousands of farms; are all of those farms constrained to plant potatoes on the same two days? Or can the days slide differently for different farms?

Rule developers want to know:
- What is a farmer? If a farmer has multiple farms, and different farms see the full moon at different times, and those times fall across the decision boundary, which of those farms is to be used for the calculation of the legal days? Do different farms get to elect different days?

Maybe one conclusion from a RaC approach is that allowing farmers to have discretion about how to slide the window creates too much complexity, and the government needs to mandate the alternative days induced by the public holiday.

* Infrastructure
The following blobs of code help with the tangle/noweb auto-generation of Haskell code from this README.

#+NAME: tangleWarning
#+begin_src haskell
-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
-- 
-- this file is autogenerated!
-- open the parent README.org in emacs and hit   C-c C-v t   to regenerate this file.
#+end_src

** Haskell Tests! TDD FTW!

#+begin_src haskell :noweb yes :tangle test/Spec.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Main where

import Test.Hspec
import Data.Maybe
import Data.Map
import Control.Monad
import SAFE.Events
import Data.Tree
import Data.Tree.Pretty
import Control.Arrow
import Debug.Trace

main :: IO ()
main = do
  forM_ [spec1] $ hspec
  return ()

<<test-setup>>

spec1 :: Spec
spec1 = do
  <<test-1>>
#+end_src

** Haskell Executable! Something shiny for a sense of accomplishment.

#+begin_src haskell :noweb yes :tangle app/Main.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Main where

import HelloWorld
import Data.Map
import Data.Tree

<<test-setup>>
<<exe>>

#+end_src

** Haskell library! Used by both the tests and the executable.

#+begin_src haskell :noweb yes :tangle src/HelloWorld.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module HelloWorld where
import Data.Map
import Data.Maybe
import Data.Tree
import Data.Time.Calendar
import Data.Time.Format.ISO8601

<<basictypes>>
<<basicimplementation>>
#+end_src

** Prolog!

#+begin_src prolog :noweb yes :tangle potato.pl
:- use_module(library(clpfd)).
:- use_module(library(julian)).
:- use_module(library(yall)).
<<prolog>>
#+end_src

You may need to

#+begin_example
pack_install(julian).
#+end_example

** Typescript!

#+begin_src typescript :tangle potato.ts
function addDays(date, days) {
  var result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

#+end_src
